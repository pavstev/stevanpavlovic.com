---
import { Icon } from 'astro-icon/components';

interface Props {
  class?: string;
  id: string;
}

const { class: className, id } = Astro.props;
---

<dialog
  class:list={[
    "group m-auto p-0 outline-none",
    // Shadcn-like Layout & Visuals
    "w-full max-w-lg gap-4 rounded-xl border border-zinc-800 bg-zinc-950 p-6 shadow-lg sm:rounded-lg",
    // Scroll handling: Max height 85vh to leave room, auto overflow for inner content
    "max-h-[85vh] overflow-y-auto",
    // Animations (Standard ease-out)
    "backdrop:animate-in backdrop:fade-in-0 backdrop:bg-black/80",
    "open:animate-in open:fade-in-0 open:zoom-in-95 open:slide-in-from-bottom-2 open:duration-200",
    className
  ]}
  id={id}
>
  {/* Close Button - Sticky to stay visible when scrolling long content */}
  <form class="sticky top-0 z-50 -mt-2 -mr-2 flex justify-end" method="dialog">
    <button
      aria-label="Close modal"
      class="rounded-sm text-zinc-100 opacity-70 ring-offset-zinc-950 transition-opacity hover:text-zinc-50 hover:opacity-100 focus:ring-2 focus:ring-zinc-400 focus:ring-offset-2 focus:outline-none disabled:pointer-events-none data-[state=open]:bg-zinc-800 data-[state=open]:text-zinc-400"
    >
      <Icon class="size-4" name="mdi:close" />
    </button>
  </form>

  {/* Content Container */}
  <div class="grid gap-4 text-zinc-50">
    <slot />
  </div>
</dialog>

<script>
  import { initModals } from '../../lib/modal';

  const setupScrollLock = () => {
    const dialogs = document.querySelectorAll('dialog');

    dialogs.forEach(dialog => {
      // Use MutationObserver to watch for the 'open' attribute
      // This ensures we catch both .showModal() calls and manual attribute toggles
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.attributeName === 'open') {
            if (dialog.hasAttribute('open')) {
              document.body.style.overflow = 'hidden';
            } else {
              document.body.style.overflow = '';
            }
          }
        });
      });

      observer.observe(dialog, { attributes: true });

      // Backup: Ensure scroll is restored when dialog is closed/cancelled events fire
      dialog.addEventListener('close', () => { document.body.style.overflow = ''; });
      dialog.addEventListener('cancel', () => { document.body.style.overflow = ''; });
    });
  };

  const init = () => {
    initModals();
    setupScrollLock();
  }

  init();
  document.addEventListener('astro:page-load', init);
</script>

<style>
  dialog {
    /* Native centering magic */
    margin: auto;
    position: fixed;
    inset: 0;

    /* Responsive width constraint */
    max-width: calc(100vw - 2rem);
  }

  /* Desktop width override to match Shadcn 'max-w-lg' tailwind class */
  @media (min-width: 640px) {
    dialog {
      max-width: 32rem; /* 512px */
    }
  }

  /* Native backdrop styling to match Tailwind utility */
  dialog::backdrop {
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(4px);
    animation: fade-in 0.2s ease-out;
  }

  @keyframes fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
  }
</style>
