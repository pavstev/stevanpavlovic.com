---
import { Icon } from 'astro-icon/components';

import Button from '../atoms/button.astro';
import Dropdown, { type DropdownOption } from '../atoms/dropdown.astro';

export interface FilterConfig {
  id: string;
  label: string;
  options: DropdownOption[];
  selectedValue?: string;
  selectedValues?: string[];
}

export type ViewMode = 'grid' | 'list';

type PaginationType = 'path' | 'query';

// @ts-expect-error "We need this one"
interface Props {
  baseUrl: string;
  currentPage: number;
  filters?: FilterConfig[];
  /** Optional: Function to generate page URL. Falls back to default logic if not provided. */
  getPageUrl?: (page: number) => string;
  itemCountLabel?: string;
  itemsPerPage?: number;
  /** Optional: Direct URL for next page (overrides auto-generation) */
  nextUrl?: string;
  paginationType?: PaginationType;
  /** Optional: Direct URL for previous page (overrides auto-generation) */
  prevUrl?: string;
  resetHref?: string;
  showItemCount?: boolean;
  showItemsPerPage?: boolean;
  showViewToggle?: boolean;
  totalItems?: number;
  totalPages: number;
  viewMode?: ViewMode;
  /** Optional: Explicit URLs for view toggles */
  viewUrls?: ViewUrls;
}

interface ViewUrls {
  grid: string;
  list: string;
}

const {
  baseUrl,
  currentPage,
  filters = [],
  getPageUrl: customGetPageUrl,
  itemCountLabel,
  itemsPerPage = 6,
  nextUrl,
  paginationType = 'path',
  prevUrl,
  resetHref,
  showItemCount = false,
  showItemsPerPage = false,
  showViewToggle = true,
  totalItems,
  totalPages,
  viewMode = 'list',
  viewUrls,
} = Astro.props;

// Get current search params to preserve filters/sorts
const currentParams = new URLSearchParams(Astro.url.searchParams);

/**
 * Helper to build a URL by merging a base path with current query params and overrides.
 */
function buildUrl(path: string, paramsToSet: Record<string, number | string | undefined> = {}): string {
  const url = new URL(path, Astro.url.origin);

  // 1. Preserve existing params
  currentParams.forEach((value, key) => {
    // In query mode, we preserve 'page' unless it's explicitly being set
    if (paginationType === 'path' && key === 'page') return;
    url.searchParams.set(key, value);
  });

  // 2. Apply new overrides
  Object.entries(paramsToSet).forEach(([key, value]) => {
    if (value === undefined || value === null) {
      url.searchParams.delete(key);
    } else {
      url.searchParams.set(key, String(value));
    }
  });

  return url.pathname + url.search;
}

// --- Pagination Logic ---
const cleanBaseUrl = baseUrl.replace(/\/$/, '');

const getPageUrl = (p: number) => {
  if (customGetPageUrl) {
    return customGetPageUrl(p);
  }

  if (paginationType === 'query') {
    // Query mode: /projects?page=2
    return buildUrl(cleanBaseUrl, { page: p });
  } else {
    // Path mode: /projects/2
    // Note: We intentionally don't use buildUrl here to keep the path clean,
    // but the button wrapper will apply buildUrl to ensure params stick.
    return p === 1 ? cleanBaseUrl : `${cleanBaseUrl}/${p}`;
  }
};

// Calculate Previous/Next Links
// Note: If using customGetPageUrl, we assume it returns a full path which acts as the base.
// We still might need to append current params if they aren't handled by customGetPageUrl.
// For safety, if customGetPageUrl is used, we wrap it in buildUrl ONLY if it's meant to be a base.
// But usually custom logic handles everything.
// Let's assume getPageUrl returns the clean path, and we wrap it to add params.
const resolveLink = (p: number) => {
  const base = getPageUrl(p);
  // If it's a query param style, it already has query params.
  // If path style, it might need params.
  // Safest check: does it include '?'?
  if (base.includes('?')) {
    // Assume logic handled it, but maybe we need to merge existing params?
    // Let's rely on buildUrl merging.
    // Complex. Let's assume default behavior for existing.
    return base;
  }
  return buildUrl(base);
};


const prevLink = prevUrl
  ? buildUrl(prevUrl)
  : currentPage > 1
    ? resolveLink(currentPage - 1)
    : undefined;

const nextLink = nextUrl
  ? buildUrl(nextUrl)
  : currentPage < totalPages
    ? resolveLink(currentPage + 1)
    : undefined;


const viewModes: { icon: string; label: string; mode: ViewMode; }[] = [
  { icon: 'mdi:format-list-bulleted', label: 'List', mode: 'list' },
  { icon: 'mdi:view-column', label: 'Grid', mode: 'grid' },
];

const itemsPerPageOptions = [
  { label: '6', value: '6' },
  { label: '9', value: '9' },
  { label: '12', value: '12' },
  { label: '24', value: '24' },
];
---

<div class="list-actions w-full">
  {/* Single row - filters left, pagination center, view toggle right */}
  <div class="flex flex-wrap items-center gap-2 border-b border-border pb-4 sm:gap-3">
    {/* Left: Filters */}
    <div class="flex flex-wrap items-center gap-2 sm:gap-3">
      {filters.map((filter: FilterConfig) => (
        <Dropdown
          align="left"
          id={`filter-${filter.id}`}
          label={filter.label}
          options={filter.options}
          selectedValue={filter.selectedValue}
          size="sm"
          variant="outline"
        />
      ))}

      {resetHref && (
        <Button
          as="a"
          class="h-7 px-2 text-xs"
          href={resetHref}
          size="sm"
          variant="ghost"
        >
          <Icon class="mr-1 size-3.5" name="mdi:refresh" />
          Reset
        </Button>
      )}
    </div>

    {/* Spacer */}
    <div class="min-w-[1rem] flex-1"></div>

    {/* Right: Controls */}
    <div class="flex flex-wrap items-center gap-2 sm:gap-3">
      {/* Total Count */}
      {showItemCount && totalItems !== undefined && (
        <span class="mr-2 hidden text-xs text-muted-foreground sm:inline-block" id="total-items-count">
          {totalItems} {itemCountLabel || 'items'}
        </span>
      )}

      {/* Items per page dropdown */}
      {showItemsPerPage && (
        <Dropdown
          align="right"
          id="items-per-page"
          label={`${itemsPerPage}`}
          options={itemsPerPageOptions.map((opt) => ({
            ...opt,
            href: buildUrl(paginationType === 'path' ? baseUrl : Astro.url.pathname, { limit: opt.value, page: 1 }), // Reset to page 1 on limit change
          }))}
          selectedValue={String(itemsPerPage)}
          size="sm"
          variant="outline"
        />
      )}

      {/* Pagination */}
      {totalPages > 1 && (
        <nav aria-label="Pagination">
          <div class="flex items-center justify-center gap-0.5 rounded-lg bg-muted/50 p-0.5 sm:gap-1 sm:p-1">
            <Button
              as="a"
              class="size-7 rounded-md p-0 sm:size-8"
              disabled={!prevLink}
              href={prevLink}
              size="icon"
              variant="ghost"
            >
              <Icon class="size-3.5 sm:size-4" name="mdi:chevron-left" />
              <span class="sr-only">Previous page</span>
            </Button>

            <div class="flex items-center px-2 sm:px-3">
              <span class="text-xs font-medium text-foreground tabular-nums sm:text-sm">
                {currentPage}
              </span>
              <span class="mx-1 text-xs text-muted-foreground sm:text-sm">
                /
              </span>
              <span class="text-xs text-muted-foreground tabular-nums sm:text-sm">
                {totalPages}
              </span>
            </div>

            <Button
              as="a"
              class="size-7 rounded-md p-0 sm:size-8"
              disabled={!nextLink}
              href={nextLink}
              size="icon"
              variant="ghost"
            >
              <Icon class="size-3.5 sm:size-4" name="mdi:chevron-right" />
              <span class="sr-only">Next page</span>
            </Button>
          </div>
        </nav>
      )}

      {/* View toggle */}
      {showViewToggle && (
        <div class="flex items-center rounded-lg border border-border bg-background p-0.5 shadow-sm sm:p-1">
          {viewModes.map(({ icon, label, mode }) => (
            <Button
              aria-pressed={viewMode === mode}
              as="a"
              class:list={[`size-7 rounded-md p-0 transition-all sm:size-8`, {
                'bg-accent text-accent-foreground shadow-sm': viewMode === mode,
                'text-muted-foreground hover:bg-muted hover:text-foreground': viewMode !== mode,
              }]}
              href={viewUrls ? buildUrl(viewUrls[mode]) : buildUrl(Astro.url.pathname, { view: mode })}
              size="icon"
              title={label}
              variant="ghost"
            >
              <Icon class="size-3.5 sm:size-4" name={icon} />
              <span class="sr-only">{label} view</span>
            </Button>
          ))}
        </div>
      )}
    </div>
  </div>
</div>
