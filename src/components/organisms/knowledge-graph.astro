---
/**
 * Feature: Interactive Knowledge Graph
 * A physics-based visualization of your professional network.
 * High-performance HTML5 Canvas implementation with shadcn theming.
 */
import { getCollection } from "astro:content";

// 1. Data Aggregation
const projects = await getCollection("projects");
const experience = await getCollection("experience");
const tags = await getCollection("tags");

// 2. Build Graph Structure
const nodes: any[] = [];
const links: any[] = [];
const tagMap = new Map();

// Helper to sanitize IDs for DOM/JS usage
const safeId = (id: string) => id.replace(/[^a-zA-Z0-9-_]/g, "_");

// A. Tags (Skills) -> "Muted" nodes
tags.forEach((tag) => {
  const id = `tag-${safeId(tag.id)}`;
  tagMap.set(tag.id, id);
  nodes.push({
    id,
    type: "tag",
    label: tag.data.label,
    baseRadius: 4,
    radius: 4, // Will grow with connections
    colorToken: "--muted-foreground",
    bgToken: "--muted",
    data: { description: tag.data.description },
  });
});

// B. Projects -> "Primary" nodes
projects.forEach((project) => {
  const id = `proj-${safeId(project.id)}`;
  nodes.push({
    id,
    type: "project",
    label: project.data.title,
    baseRadius: 10,
    radius: 10,
    colorToken: "--primary-foreground",
    bgToken: "--primary",
    data: {
      desc: project.data.description,
      role: project.data.role,
      link: project.data.demoUrl || project.data.repoUrl,
    },
  });

  // Link Project -> Tags
  project.data.tags.forEach((tagRef) => {
    if (tagMap.has(tagRef.id)) {
      links.push({ source: id, target: tagMap.get(tagRef.id) });
      const tagNode = nodes.find((n) => n.id === tagMap.get(tagRef.id));
      if (tagNode) tagNode.radius += 1.5; // Grow importance
    }
  });
});

// C. Experience -> "Accent" nodes
experience.forEach((job) => {
  const id = `exp-${safeId(job.id)}`;
  nodes.push({
    id,
    type: "experience",
    label: job.data.role,
    baseRadius: 12,
    radius: 12,
    colorToken: "--accent-foreground",
    bgToken: "--accent",
    data: { desc: job.data.description },
  });

  // Link Job -> Tags
  job.data.tags?.forEach((tagRef) => {
    if (tagMap.has(tagRef.id)) {
      links.push({ source: id, target: tagMap.get(tagRef.id) });
      const tagNode = nodes.find((n) => n.id === tagMap.get(tagRef.id));
      if (tagNode) tagNode.radius += 2; // Jobs boost skill importance more
    }
  });
});

const graphData = { nodes, links };
---

<section
  class="relative w-full h-[600px] md:h-[800px] bg-background border border-border rounded-xl overflow-hidden group select-none shadow-sm"
  id="graph-container"
>
  <!-- Canvas Layer -->
  <canvas id="knowledge-graph" class="absolute inset-0 block outline-none cursor-grab active:cursor-grabbing"></canvas>

  <!-- UI Overlay: Controls -->
  <div class="absolute bottom-4 left-4 flex flex-col gap-2 z-10 pointer-events-none">
    <!-- Legend -->
    <div
      class="px-3 py-2 bg-card/80 text-card-foreground text-[10px] font-medium uppercase tracking-wider rounded-md border border-border backdrop-blur-sm shadow-sm pointer-events-auto"
    >
      <div class="flex items-center gap-2 mb-1">
        <span class="w-2 h-2 rounded-sm bg-primary"></span> Project
      </div>
      <div class="flex items-center gap-2 mb-1">
        <span class="w-2 h-2 rounded-full bg-accent border border-border"></span> Job
      </div>
      <div class="flex items-center gap-2">
        <span class="w-2 h-2 rounded-full bg-muted border border-border"></span> Skill
      </div>
    </div>

    <!-- Reset Button -->
    <button
      id="reset-cam"
      class="self-start px-3 py-1.5 bg-secondary text-secondary-foreground text-[10px] font-bold uppercase tracking-wider rounded-md border border-border hover:bg-secondary/80 transition-colors pointer-events-auto shadow-sm"
    >
      Reset View
    </button>
  </div>

  <!-- UI Overlay: Node Tooltip (Shadcn Popover Style) -->
  <div
    id="node-tooltip"
    class="absolute top-0 left-0 max-w-[280px] p-4 bg-popover text-popover-foreground rounded-lg border border-border shadow-md pointer-events-none opacity-0 transition-opacity duration-200 z-50"
    style="will-change: transform, opacity;"
  >
    <div class="flex flex-col gap-1">
      <span class="text-[10px] font-bold uppercase tracking-wider text-muted-foreground" id="tt-type">Type</span>
      <h3 class="text-sm font-semibold leading-none tracking-tight" id="tt-title">Title</h3>
      <p class="text-xs text-muted-foreground leading-relaxed line-clamp-4 mt-1" id="tt-desc">Description</p>
    </div>
  </div>
</section>

<script is:inline define:vars={{ graphData }}>
  /**
   * KNOWLEDGE GRAPH ENGINE
   * Force-directed graph using HTML5 Canvas with Shadcn styling.
   */
  const container = document.getElementById("graph-container");
  const canvas = document.getElementById("knowledge-graph");
  const ctx = canvas.getContext("2d", { alpha: true }); // Alpha for transparency
  const tooltip = document.getElementById("node-tooltip");

  // --- Theme Integration ---
  // Helper to get CSS variable values dynamically
  const getThemeColor = (varName) => {
    const root = getComputedStyle(document.documentElement);
    const hsl = root.getPropertyValue(varName).trim();
    if (!hsl) return "#888"; // Fallback
    // Convert "H S% L%" to CSS color string
    return `hsl(${hsl})`;
  };

  // --- Configuration ---
  const CONFIG = {
    particleCount: 25,
    linkDistance: 120,
    repulsion: 400,
    spring: 0.02,
    friction: 0.88,
    gravity: 0.03,
    colors: {
      border: getThemeColor("--border"),
      primary: getThemeColor("--primary"),
      activeLink: getThemeColor("--primary"),
      particle: getThemeColor("--primary"),
    },
  };

  // --- State Initialization ---
  let width = container.offsetWidth;
  let height = container.offsetHeight;

  // Transform nodes to include physics state
  let nodes = graphData.nodes.map((n) => ({
    ...n,
    x: Math.random() * width,
    y: Math.random() * height,
    vx: (Math.random() - 0.5) * 2,
    vy: (Math.random() - 0.5) * 2,
    // Resolve colors once on init (and on theme change ideally, but keeping simple)
    bg: getThemeColor(n.bgToken),
    fg: getThemeColor(n.colorToken),
    border: getThemeColor("--border"),
  }));

  const nodeMap = new Map(nodes.map((n) => [n.id, n]));
  let links = graphData.links
    .map((l) => ({ source: nodeMap.get(l.source), target: nodeMap.get(l.target) }))
    .filter((l) => l.source && l.target);

  let particles = [];
  let cam = { x: width / 2, y: height / 2, zoom: 0.8, targetX: width / 2, targetY: height / 2, targetZoom: 0.8 };
  let isDragging = false;
  let dragNode = null;
  let hoverNode = null;
  let mouse = { x: 0, y: 0 };

  // --- Resizing ---
  const resizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      const { width: w, height: h } = entry.contentRect;
      width = w;
      height = h;
      // Handle high DPI displays
      const dpr = window.devicePixelRatio || 1;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      ctx.scale(dpr, dpr);

      // Re-center if first load
      if (!cam.x) {
        cam.x = w / 2;
        cam.y = h / 2;
      }
    }
  });
  resizeObserver.observe(container);

  // --- Physics Loop ---
  function update() {
    // Smooth Camera
    cam.x += (cam.targetX - cam.x) * 0.1;
    cam.y += (cam.targetY - cam.y) * 0.1;
    cam.zoom += (cam.targetZoom - cam.zoom) * 0.1;

    // Forces
    for (let i = 0; i < nodes.length; i++) {
      let node = nodes[i];

      // Central Gravity (keep graph centered)
      node.vx -= node.x * CONFIG.gravity * 0.05;
      node.vy -= node.y * CONFIG.gravity * 0.05;

      // Node Repulsion
      for (let j = i + 1; j < nodes.length; j++) {
        let other = nodes[j];
        let dx = other.x - node.x;
        let dy = other.y - node.y;
        let distSq = dx * dx + dy * dy || 1;

        if (distSq < 100000) {
          // Optimization: Ignore far away nodes
          let force = (CONFIG.repulsion * 50) / distSq;
          let angle = Math.atan2(dy, dx);
          let fx = Math.cos(angle) * force;
          let fy = Math.sin(angle) * force;

          node.vx -= fx;
          node.vy -= fy;
          other.vx += fx;
          other.vy += fy;
        }
      }
    }

    // Link Springs
    links.forEach((link) => {
      let dx = link.target.x - link.source.x;
      let dy = link.target.y - link.source.y;
      let dist = Math.sqrt(dx * dx + dy * dy) || 1;

      let force = (dist - CONFIG.linkDistance) * CONFIG.spring;
      let angle = Math.atan2(dy, dx);
      let fx = Math.cos(angle) * force;
      let fy = Math.sin(angle) * force;

      link.source.vx += fx;
      link.source.vy += fy;
      link.target.vx -= fx;
      link.target.vy -= fy;
    });

    // Integration
    nodes.forEach((node) => {
      if (node === dragNode) return;
      node.vx *= CONFIG.friction;
      node.vy *= CONFIG.friction;
      node.x += node.vx;
      node.y += node.vy;
    });

    // Particles
    if (particles.length < CONFIG.particleCount && Math.random() > 0.95) {
      const link = links[Math.floor(Math.random() * links.length)];
      particles.push({ link, progress: 0, speed: 0.01 + Math.random() * 0.02 });
    }
    particles.forEach((p, i) => {
      p.progress += p.speed;
      if (p.progress >= 1) particles.splice(i, 1);
    });
  }

  // --- Render Loop ---
  function draw() {
    ctx.clearRect(0, 0, width, height);

    ctx.save();
    ctx.translate(width / 2, height / 2); // Center of viewport
    ctx.scale(cam.zoom, cam.zoom);
    ctx.translate(-width / 2 + cam.x, -height / 2 + cam.y); // Camera Pan

    // 1. Draw Links
    ctx.lineWidth = 1;
    ctx.strokeStyle = CONFIG.colors.border;
    ctx.beginPath();
    links.forEach((link) => {
      ctx.moveTo(link.source.x, link.source.y);
      ctx.lineTo(link.target.x, link.target.y);
    });
    ctx.stroke();

    // 2. Highlight Active Links (Hover)
    if (hoverNode) {
      ctx.strokeStyle = CONFIG.colors.activeLink;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      links.forEach((link) => {
        if (link.source === hoverNode || link.target === hoverNode) {
          ctx.moveTo(link.source.x, link.source.y);
          ctx.lineTo(link.target.x, link.target.y);
        }
      });
      ctx.stroke();
    }

    // 3. Draw Particles
    ctx.fillStyle = CONFIG.colors.particle;
    particles.forEach((p) => {
      const x = p.link.source.x + (p.link.target.x - p.link.source.x) * p.progress;
      const y = p.link.source.y + (p.link.target.y - p.link.source.y) * p.progress;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    });

    // 4. Draw Nodes
    nodes.forEach((node) => {
      const isHover = node === hoverNode;
      const r = node.radius + (isHover ? 4 : 0);

      // Node Shadow/Glow
      if (isHover) {
        ctx.shadowColor = node.bg;
        ctx.shadowBlur = 15;
      } else {
        ctx.shadowBlur = 0;
      }

      ctx.fillStyle = node.bg;
      ctx.strokeStyle = isHover ? CONFIG.colors.primary : node.border;
      ctx.lineWidth = isHover ? 2 : 1;

      ctx.beginPath();
      if (node.type === "project") {
        // Rounded Rect for Projects
        const s = r * 1.8;
        ctx.roundRect(node.x - s / 2, node.y - s / 2, s, s, 4);
      } else if (node.type === "experience") {
        // Circle with border for Job
        ctx.arc(node.x, node.y, r, 0, Math.PI * 2);
      } else {
        // Smaller circle for tags
        ctx.arc(node.x, node.y, r, 0, Math.PI * 2);
      }
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0; // Reset

      // Text Labels
      if (r > 8 || isHover) {
        ctx.font = isHover ? "600 12px Inter, sans-serif" : "500 10px Inter, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Draw background for text readability
        const labelY = node.y + r + 12;
        ctx.fillStyle = isHover ? node.fg : getThemeColor("--muted-foreground");
        ctx.fillText(node.label, node.x, labelY);
      }
    });

    ctx.restore();
    requestAnimationFrame(render);
  }

  function render() {
    update();
    draw();
  }
  requestAnimationFrame(render);

  // --- Interaction ---
  const getWorldPos = (clientX, clientY) => {
    const rect = canvas.getBoundingClientRect();
    // Adjust for camera
    const cx = width / 2;
    const cy = height / 2;
    // Map screen to canvas
    const mx = clientX - rect.left;
    const my = clientY - rect.top;
    // Inverse camera matrix
    return {
      x: (mx - cx) / cam.zoom - (cam.x - cx) + cx,
      y: (my - cy) / cam.zoom - (cam.y - cy) + cy,
    };
  };

  canvas.addEventListener("mousemove", (e) => {
    const wPos = getWorldPos(e.clientX, e.clientY);

    // Find node under mouse
    let found = null;
    let minDist = Infinity;

    for (const node of nodes) {
      const dx = node.x - wPos.x;
      const dy = node.y - wPos.y;
      const dist = dx * dx + dy * dy;
      const hitRadius = (node.radius + 10) ** 2; // Generous hit area

      if (dist < hitRadius && dist < minDist) {
        minDist = dist;
        found = node;
      }
    }

    hoverNode = found;
    canvas.style.cursor = hoverNode ? "pointer" : isDragging ? "grabbing" : "grab";

    if (isDragging && dragNode) {
      dragNode.x = wPos.x;
      dragNode.y = wPos.y;
      dragNode.vx = 0;
      dragNode.vy = 0;
    }

    // Update Tooltip
    if (hoverNode) {
      tooltip.style.opacity = "1";
      // Basic collision detection for tooltip to keep it on screen
      let tx = e.clientX + 20;
      let ty = e.clientY + 20;

      tooltip.style.transform = `translate(${tx}px, ${ty}px)`;

      document.getElementById("tt-title").innerText = hoverNode.label;
      document.getElementById("tt-type").innerText = hoverNode.type;
      document.getElementById("tt-desc").innerText = hoverNode.data?.desc || hoverNode.data?.description || "";
      document.getElementById("tt-type").style.color = hoverNode.bg;
    } else {
      tooltip.style.opacity = "0";
    }
  });

  canvas.addEventListener("mousedown", (e) => {
    if (hoverNode) {
      isDragging = true;
      dragNode = hoverNode;
    }
  });

  window.addEventListener("mouseup", () => {
    isDragging = false;
    dragNode = null;
  });

  // Zoom
  container.addEventListener(
    "wheel",
    (e) => {
      e.preventDefault();
      cam.targetZoom += e.deltaY * -0.001;
      cam.targetZoom = Math.min(Math.max(0.1, cam.targetZoom), 4);
    },
    { passive: false },
  );

  // Reset
  document.getElementById("reset-cam").addEventListener("click", () => {
    cam.targetX = 0; // Relative to center calc in update
    cam.targetY = 0;
    cam.targetZoom = 0.8;
    // Force re-centering logic
    const w = container.offsetWidth;
    const h = container.offsetHeight;
    cam.x = w / 2;
    cam.y = h / 2;
    cam.zoom = 0.8;
  });
</script>
