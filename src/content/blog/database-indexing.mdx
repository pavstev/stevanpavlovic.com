---
title: "Database Indexing Strategies for Performance"
description: "Master database indexes to dramatically improve query performance"
pubDate: "2024-02-18"
tags: ["database", "performance", "sql"]
heroImage: "../../assets/laptop-desk.jpg"
---

Indexes are one of the most powerful tools for database optimization. Used correctly, they can transform slow queries into lightning-fast ones.

## When to Use Indexes

```sql
-- Index on frequently queried columns
CREATE INDEX idx_users_email ON users(email);

-- Composite index for multi-column queries
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);

-- Unique index for constraint enforcement
CREATE UNIQUE INDEX idx_users_username ON users(username);
```

## Index Types

### B-Tree Indexes (Default)

Best for equality and range queries:

```sql
-- Efficient with B-Tree
SELECT * FROM users WHERE email = 'user@example.com';
SELECT * FROM orders WHERE created_at BETWEEN '2024-01-01' AND '2024-02-01';
```

### Hash Indexes

Perfect for equality comparisons:

```sql
-- PostgreSQL hash index
CREATE INDEX idx_sessions_token ON sessions USING HASH (token);

-- Use case
SELECT * FROM sessions WHERE token = 'abc123';
```

### Partial Indexes

Index only a subset of data:

```sql
-- Only index active users
CREATE INDEX idx_users_active ON users(email) WHERE status = 'active';

-- Smaller, more efficient for specific queries
SELECT * FROM users WHERE email = 'user@example.com' AND status = 'active';
```

## Composite Index Order Matters

```sql
-- Index can be used for:
-- (a), (a,b), (a,b,c)
-- But NOT for (b), (c), or (b,c)
CREATE INDEX idx_multi ON table(a, b, c);

-- ✅ Uses index
SELECT * FROM table WHERE a = 1;
SELECT * FROM table WHERE a = 1 AND b = 2;

-- ❌ Doesn't use index efficiently
SELECT * FROM table WHERE b = 2;
SELECT * FROM table WHERE c = 3;
```

## Covering Indexes

Include all query columns in the index:

```sql
-- Includes columns needed by query
CREATE INDEX idx_users_login ON users(email) INCLUDE (password_hash, last_login);

-- This query only reads the index, not the table
SELECT password_hash, last_login
FROM users
WHERE email = 'user@example.com';
```

## Analyzing Query Plans

```sql
-- PostgreSQL
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE user_id = 123
AND created_at > '2024-01-01';

-- Look for:
-- - Index Scan vs Seq Scan
-- - Actual time vs estimated
-- - Rows returned vs estimated
```

## Index Maintenance

Indexes aren't free - they cost storage and slow down writes:

```typescript
// Monitor index usage (PostgreSQL)
const unusedIndexes = await db.query(`
  SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan
  FROM pg_stat_user_indexes
  WHERE idx_scan = 0
  ORDER BY pg_relation_size(indexrelid) DESC
`);

// Remove unused indexes
for (const index of unusedIndexes) {
  await db.query(`DROP INDEX ${index.indexname}`);
}
```

## Best Practices

1. **Index WHERE clauses** - Columns in your conditions
2. **Index foreign keys** - JOIN performance
3. **Watch cardinality** - High unique values work best
4. **Monitor query plans** - Verify indexes are used
5. **Consider write costs** - Each index slows inserts/updates
6. **Rebuild periodically** - Fragmentation affects performance

Remember: Profile first, index strategically, measure improvement!
