---
title: 'Domain-Driven Design Fundamentals'
description: 'Build maintainable software by aligning code with business domains'
pubDate: '2024-03-05'
tags: ['ddd', 'architecture', 'design', 'patterns']
heroImage: '../../assets/satellite-tech.jpg'
---

Domain-Driven Design (DDD) helps manage complexity by organizing code around business concepts.

## Ubiquitous Language

Everyone uses the same terms:

```typescript
// ❌ BAD - Technical jargon
class DataProcessor {
  async processRecord(rec: Record): Promise<void> {
    await this.repo.save(rec);
  }
}

// ✅ GOOD - Business language
class OrderService {
  async placeOrder(order: Order): Promise<void> {
    await this.orderRepository.save(order);
  }
}
```

## Entities

Objects with unique identity:

```typescript
class Order {
  constructor(
    public readonly id: OrderId,  // Identity
    public customerId: CustomerId,
    private items: OrderItem[],
    private status: OrderStatus
  ) {}

  addItem(item: OrderItem): void {
    if (this.status !== OrderStatus.Draft) {
      throw new Error('Cannot modify confirmed order');
    }
    this.items.push(item);
  }

  confirm(): void {
    if (this.items.length === 0) {
      throw new Error('Cannot confirm empty order');
    }
    this.status = OrderStatus.Confirmed;
  }

  // Entity equality based on ID
  equals(other: Order): boolean {
    return this.id.equals(other.id);
  }
}
```

## Value Objects

Objects without identity, defined by attributes:

```typescript
class Money {
  constructor(
    public readonly amount: number,
    public readonly currency: string
  ) {
    if (amount < 0) {
      throw new Error('Amount cannot be negative');
    }
  }

  add(other: Money): Money {
    if (this.currency !== other.currency) {
      throw new Error('Currency mismatch');
    }
    return new Money(this.amount + other.amount, this.currency);
  }

  // Value object equality based on attributes
  equals(other: Money): boolean {
    return this.amount === other.amount &&
           this.currency === other.currency;
  }
}

class Address {
  constructor(
    public readonly street: string,
    public readonly city: string,
    public readonly zipCode: string
  ) {}

  equals(other: Address): boolean {
    return this.street === other.street &&
           this.city === other.city &&
           this.zipCode === other.zipCode;
  }
}
```

## Aggregates

Cluster of entities and value objects:

```typescript
// Order is the aggregate root
class Order {
  private items: OrderItem[] = [];
  private readonly maxItems = 100;

  addItem(product: Product, quantity: number): void {
    // Aggregate enforces invariants
    if (this.items.length >= this.maxItems) {
      throw new Error('Order has too many items');
    }

    const existing = this.items.find(i =>
      i.productId.equals(product.id)
    );

    if (existing) {
      existing.increaseQuantity(quantity);
    } else {
      this.items.push(new OrderItem(product.id, quantity));
    }
  }

  calculateTotal(): Money {
    return this.items.reduce(
      (total, item) => total.add(item.total),
      new Money(0, 'USD')
    );
  }
}

// OrderItem is part of the Order aggregate
class OrderItem {
  constructor(
    public readonly productId: ProductId,
    private quantity: number
  ) {}

  increaseQuantity(amount: number): void {
    this.quantity += amount;
  }

  get total(): Money {
    // Simplified - would get price from product
    return new Money(this.quantity * 10, 'USD');
  }
}
```

## Repositories

Access aggregates:

```typescript
interface OrderRepository {
  findById(id: OrderId): Promise<Order | null>;
  save(order: Order): Promise<void>;
  findByCustomer(customerId: CustomerId): Promise<Order[]>;
}

class MongoOrderRepository implements OrderRepository {
  async findById(id: OrderId): Promise<Order | null> {
    const doc = await this.collection.findOne({ _id: id.value });
    return doc ? this.toDomain(doc) : null;
  }

  async save(order: Order): Promise<void> {
    const doc = this.toDocument(order);
    await this.collection.replaceOne(
      { _id: order.id.value },
      doc,
      { upsert: true }
    );
  }

  private toDomain(doc: any): Order {
    // Map database model to domain model
  }

  private toDocument(order: Order): any {
    // Map domain model to database model
  }
}
```

## Domain Services

Operations that don't belong to entities:

```typescript
class PricingService {
  calculateOrderPrice(
    order: Order,
    customer: Customer,
    promotions: Promotion[]
  ): Money {
    let total = order.calculateTotal();

    // Apply customer discount
    if (customer.isPremium) {
      total = total.multiply(0.9);
    }

    // Apply promotions
    for (const promotion of promotions) {
      total = promotion.apply(total);
    }

    return total;
  }
}
```

## Bounded Contexts

Separate models for different contexts:

```typescript
// E-commerce context
namespace ECommerce {
  class Product {
    id: ProductId;
    name: string;
    price: Money;
    inventory: number;
  }
}

// Shipping context
namespace Shipping {
  class Product {
    id: ProductId;
    weight: number;
    dimensions: Dimensions;
  }
}

// Different concerns, different models!
```

## Best Practices

1. **Start with the domain** - Understand the business first
2. **Use ubiquitous language** - Same terms everywhere
3. **Protect invariants** - Aggregates enforce rules
4. **Keep aggregates small** - Only what needs consistency
5. **Model behavior** - Rich domain models, not anemic
6. **Separate concerns** - Bounded contexts for different domains

DDD shines in complex domains. For simple CRUD, it might be overkill.
