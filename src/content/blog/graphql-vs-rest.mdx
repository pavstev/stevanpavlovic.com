---
title: 'GraphQL vs REST: Architecture Comparison'
description: 'When to choose GraphQL over REST and how to implement each effectively'
pubDate: '2024-02-28'
tags: ['graphql', 'rest', 'api', 'architecture']
heroImage: '../../assets/satellite-tech.jpg'
---

GraphQL and REST both solve API design problems, but in different ways. Here's how to choose.

## REST Fundamentals

Resource-based architecture:

```typescript
// Multiple endpoints for related data
GET /users/123
GET /users/123/posts
GET /users/123/comments

// Multiple round trips
async function getUserWithData(userId: string) {
  const user = await fetch(`/api/users/${userId}`);
  const posts = await fetch(`/api/users/${userId}/posts`);
  const comments = await fetch(`/api/users/${userId}/comments`);

  return {
    ...user,
    posts,
    comments
  };
}
```

## GraphQL Single Endpoint

```graphql
query GetUserWithData($userId: ID!) {
  user(id: $userId) {
    id
    name
    email
    posts {
      id
      title
      content
    }
    comments {
      id
      text
      post {
        title
      }
    }
  }
}
```

## GraphQL Server Implementation

```typescript
import { ApolloServer } from '@apollo/server';
import { gql } from 'graphql-tag';

const typeDefs = gql`
  type User {
    id: ID!
    name: String!
    email: String!
    posts: [Post!]!
    comments: [Comment!]!
  }

  type Post {
    id: ID!
    title: String!
    content: String!
    author: User!
  }

  type Query {
    user(id: ID!): User
    users: [User!]!
  }

  type Mutation {
    createUser(name: String!, email: String!): User!
    updateUser(id: ID!, name: String, email: String): User!
  }
`;

const resolvers = {
  Query: {
    user: (_, { id }) => User.findById(id),
    users: () => User.find()
  },
  Mutation: {
    createUser: (_, { name, email }) => User.create({ name, email }),
    updateUser: (_, { id, ...data }) => User.findByIdAndUpdate(id, data)
  },
  User: {
    posts: (user) => Post.find({ authorId: user.id }),
    comments: (user) => Comment.find({ userId: user.id })
  }
};

const server = new ApolloServer({ typeDefs, resolvers });
```

## N+1 Problem in GraphQL

```typescript
// ❌ BAD - N+1 queries
const resolvers = {
  User: {
    posts: (user) => {
      // Called once per user!
      return Post.find({ authorId: user.id });
    }
  }
};

// ✅ GOOD - Use DataLoader
import DataLoader from 'dataloader';

const postLoader = new DataLoader(async (userIds) => {
  const posts = await Post.find({ authorId: { $in: userIds } });
  return userIds.map(id => posts.filter(p => p.authorId === id));
});

const resolvers = {
  User: {
    posts: (user) => postLoader.load(user.id)
  }
};
```

## When to Use REST

- **Simple CRUD operations** - Standard resource patterns
- **Caching is crucial** - HTTP caching works well
- **Public APIs** - Widely understood, lots of tooling
- **File uploads** - Simpler with REST
- **Team familiarity** - Lower learning curve

## When to Use GraphQL

- **Mobile applications** - Minimize data transfer
- **Aggregating microservices** - Single gateway
- **Rapid frontend iteration** - No backend changes needed
- **Complex data requirements** - Flexible querying
- **Real-time needs** - Built-in subscriptions

## Hybrid Approach

```typescript
// REST for simple operations
app.get('/api/health', (req, res) => res.json({ status: 'ok' }));
app.post('/api/upload', upload.single('file'), handleUpload);

// GraphQL for complex queries
app.use('/graphql', expressMiddleware(apolloServer));
```

## Best Practices

### REST
1. Use proper HTTP methods and status codes
2. Version your API
3. Implement pagination
4. Document with OpenAPI

### GraphQL
1. Use DataLoader to prevent N+1
2. Implement query complexity limits
3. Add pagination (relay-style)
4. Monitor and limit query depth

Both are tools. Choose based on your specific needs, not hype!
